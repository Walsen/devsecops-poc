name: Deploy

on:
  push:
    branches: [main]
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.gitignore'
      - '.gitleaks.toml'
      - 'scripts/**'
      - 'ruff.toml'
      - '.vscode/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      infra_type:
        description: 'Infrastructure type'
        required: true
        default: 'containers'
        type: choice
        options:
          - containers    # ECS Fargate (infra/)
          - serverless    # Lambda + DynamoDB (infra-fs/)
      force_all:
        description: 'Force full pipeline (ignore path filters)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  PYTHON_VERSION: "3.12"
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com

jobs:
  # ============================================================
  # Detect what changed to skip unnecessary jobs
  # ============================================================
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.filter.outputs.services }}
      infra: ${{ steps.filter.outputs.infra }}
      infra_fs: ${{ steps.filter.outputs.infra_fs }}
      web: ${{ steps.filter.outputs.web }}
      lambdas: ${{ steps.filter.outputs.lambdas }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changed paths
        id: filter
        run: |
          if [ "${{ inputs.force_all }}" = "true" ] || [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "services=true" >> $GITHUB_OUTPUT
            echo "infra=true" >> $GITHUB_OUTPUT
            echo "infra_fs=true" >> $GITHUB_OUTPUT
            echo "web=true" >> $GITHUB_OUTPUT
            echo "lambdas=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")

          # Service code (api/, worker/, scheduler/) — need Docker rebuild
          if echo "$CHANGED" | grep -qE '^(api|worker|scheduler)/'; then
            echo "services=true" >> $GITHUB_OUTPUT
          else
            echo "services=false" >> $GITHUB_OUTPUT
          fi

          # Container infra (infra/)
          if echo "$CHANGED" | grep -qE '^infra/'; then
            echo "infra=true" >> $GITHUB_OUTPUT
          else
            echo "infra=false" >> $GITHUB_OUTPUT
          fi

          # Serverless infra (infra-fs/)
          if echo "$CHANGED" | grep -qE '^infra-fs/'; then
            echo "infra_fs=true" >> $GITHUB_OUTPUT
          else
            echo "infra_fs=false" >> $GITHUB_OUTPUT
          fi

          # Frontend (web/)
          if echo "$CHANGED" | grep -qE '^web/'; then
            echo "web=true" >> $GITHUB_OUTPUT
          else
            echo "web=false" >> $GITHUB_OUTPUT
          fi

          # Lambda handlers (api-lambda/, worker-lambda/, scheduler-lambda/)
          if echo "$CHANGED" | grep -qE '^(api-lambda|worker-lambda|scheduler-lambda)/'; then
            echo "lambdas=true" >> $GITHUB_OUTPUT
          else
            echo "lambdas=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================
  # Determine infrastructure type
  # ============================================================
  setup:
    name: Setup
    runs-on: ubuntu-latest
    needs: [changes]
    outputs:
      infra_type: ${{ steps.set-infra.outputs.infra_type }}
      infra_dir: ${{ steps.set-infra.outputs.infra_dir }}
      need_containers: ${{ steps.set-infra.outputs.need_containers }}
      need_cdk: ${{ steps.set-infra.outputs.need_cdk }}
      need_serverless_cdk: ${{ steps.set-infra.outputs.need_serverless_cdk }}
    steps:
      - name: Set infrastructure type
        id: set-infra
        env:
          INFRA_TYPE_INPUT: ${{ inputs.infra_type || 'containers' }}
        run: |
          echo "infra_type=$INFRA_TYPE_INPUT" >> $GITHUB_OUTPUT
          if [ "$INFRA_TYPE_INPUT" == "serverless" ]; then
            echo "infra_dir=infra-fs" >> $GITHUB_OUTPUT
          else
            echo "infra_dir=infra" >> $GITHUB_OUTPUT
          fi

          # For containers mode: need Docker builds if service code changed
          SERVICES="${{ needs.changes.outputs.services }}"
          INFRA="${{ needs.changes.outputs.infra }}"
          WEB="${{ needs.changes.outputs.web }}"

          if [ "$INFRA_TYPE_INPUT" == "containers" ]; then
            # Need container builds when service code changes
            echo "need_containers=$SERVICES" >> $GITHUB_OUTPUT
            # Need CDK when infra, services, or web changed
            if [ "$INFRA" = "true" ] || [ "$SERVICES" = "true" ] || [ "$WEB" = "true" ]; then
              echo "need_cdk=true" >> $GITHUB_OUTPUT
            else
              echo "need_cdk=false" >> $GITHUB_OUTPUT
            fi
            echo "need_serverless_cdk=false" >> $GITHUB_OUTPUT
          else
            echo "need_containers=false" >> $GITHUB_OUTPUT
            echo "need_cdk=false" >> $GITHUB_OUTPUT
            # Need serverless CDK when infra-fs, lambdas, or web changed
            INFRA_FS="${{ needs.changes.outputs.infra_fs }}"
            LAMBDAS="${{ needs.changes.outputs.lambdas }}"
            if [ "$INFRA_FS" = "true" ] || [ "$LAMBDAS" = "true" ] || [ "$WEB" = "true" ]; then
              echo "need_serverless_cdk=true" >> $GITHUB_OUTPUT
            else
              echo "need_serverless_cdk=false" >> $GITHUB_OUTPUT
            fi
          fi


  # ============================================================
  # Deploy ECR repositories (must exist before container builds)
  # ============================================================
  deploy-registry:
    name: Deploy Registry
    runs-on: ubuntu-latest
    needs: [setup]
    if: needs.setup.outputs.need_containers == 'true'
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Set up Python
        run: uv python install ${{ env.PYTHON_VERSION }}

      - name: Install CDK
        run: npm install -g aws-cdk

      - name: Deploy RegistryStack
        run: |
          uv run --directory infra cdk deploy RegistryStack \
            --require-approval never

  # ============================================================
  # Build and push container images (only when service code changed)
  # ============================================================
  build-and-push:
    name: Build & Push
    runs-on: ubuntu-latest
    needs: [setup, deploy-registry]
    if: needs.setup.outputs.need_containers == 'true'
    permissions:
      id-token: write
      contents: read
    strategy:
      matrix:
        service: [api, worker, scheduler]

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ECR_REGISTRY }}/${{ matrix.service }}
          tags: |
            type=sha,prefix=
            type=raw,value=${{ github.sha }}
            type=raw,value=latest

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          file: ./${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true

  # ============================================================
  # Save ECS desired counts before CDK deploy (prevent reset to 0)
  # ============================================================
  save-ecs-state:
    name: Save ECS State
    runs-on: ubuntu-latest
    needs: [setup]
    if: needs.setup.outputs.infra_type == 'containers' && needs.setup.outputs.need_cdk == 'true'
    permissions:
      id-token: write
      contents: read
    outputs:
      api_count: ${{ steps.counts.outputs.api }}
      worker_count: ${{ steps.counts.outputs.worker }}
      scheduler_count: ${{ steps.counts.outputs.scheduler }}
      has_cluster: ${{ steps.counts.outputs.has_cluster }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Read current desired counts
        id: counts
        run: |
          CLUSTER=$(aws ecs list-clusters \
            --query "clusterArns[?contains(@, 'ComputeStack')]" \
            --output text 2>/dev/null || true)

          if [ -z "$CLUSTER" ]; then
            echo "No ECS cluster found, using defaults"
            echo "api=0" >> $GITHUB_OUTPUT
            echo "worker=0" >> $GITHUB_OUTPUT
            echo "scheduler=0" >> $GITHUB_OUTPUT
            echo "has_cluster=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "has_cluster=true" >> $GITHUB_OUTPUT

          # Discover actual service ARNs dynamically (CDK generates unique names)
          SVCS=$(aws ecs list-services --cluster "$CLUSTER" --query "serviceArns[]" --output text 2>/dev/null || true)

          for svc_arn in $SVCS; do
            SVC_NAME=$(echo "$svc_arn" | awk -F'/' '{print $NF}')
            COUNT=$(aws ecs describe-services \
              --cluster "$CLUSTER" \
              --services "$svc_arn" \
              --query "services[0].desiredCount" \
              --output text 2>/dev/null || echo "0")
            if [ "$COUNT" = "None" ] || [ -z "$COUNT" ]; then
              COUNT=0
            fi

            # Map CDK service name to logical name for outputs
            if echo "$SVC_NAME" | grep -qi "api"; then
              echo "api=${COUNT}" >> $GITHUB_OUTPUT
              echo "  api ($SVC_NAME) desired count: ${COUNT}"
            elif echo "$SVC_NAME" | grep -qi "worker"; then
              echo "worker=${COUNT}" >> $GITHUB_OUTPUT
              echo "  worker ($SVC_NAME) desired count: ${COUNT}"
            elif echo "$SVC_NAME" | grep -qi "scheduler"; then
              echo "scheduler=${COUNT}" >> $GITHUB_OUTPUT
              echo "  scheduler ($SVC_NAME) desired count: ${COUNT}"
            fi
          done

  # ============================================================
  # Deploy CDK infrastructure (containers mode)
  # ============================================================
  deploy-cdk:
    name: Deploy CDK
    runs-on: ubuntu-latest
    needs: [setup, changes, build-and-push, save-ecs-state]
    if: |
      always()
      && needs.setup.result == 'success'
      && needs.setup.outputs.need_cdk == 'true'
      && (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')
      && (needs.save-ecs-state.result == 'success' || needs.save-ecs-state.result == 'skipped')
    permissions:
      id-token: write
      contents: read
    environment: ${{ inputs.environment || 'dev' }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Set up Python
        run: uv python install ${{ env.PYTHON_VERSION }}

      - name: Install CDK
        run: npm install -g aws-cdk

      - name: Determine stacks to deploy
        id: stacks
        run: |
          SERVICES="${{ needs.changes.outputs.services }}"
          INFRA="${{ needs.changes.outputs.infra }}"
          WEB="${{ needs.changes.outputs.web }}"
          IS_DISPATCH="${{ github.event_name == 'workflow_dispatch' }}"

          # Always deploy these core stacks when infra changes or manual dispatch
          if [ "$INFRA" = "true" ] || [ "$IS_DISPATCH" = "true" ]; then
            echo "names=NetworkStack SecurityStack AuthStack DataStack ComputeStack ObservabilityStack ComplianceStack ThreatDetectionStack FrontendStack" >> $GITHUB_OUTPUT
            exit 0
          fi

          STACKS=""

          # Service code changed — need ComputeStack for new task definitions
          if [ "$SERVICES" = "true" ]; then
            STACKS="NetworkStack SecurityStack AuthStack DataStack ComputeStack ObservabilityStack"
          fi

          # Frontend changed — need FrontendStack (Amplify env vars)
          if [ "$WEB" = "true" ]; then
            if [ -z "$STACKS" ]; then
              STACKS="FrontendStack"
            else
              STACKS="$STACKS FrontendStack"
            fi
          fi

          echo "names=$STACKS" >> $GITHUB_OUTPUT

      - name: CDK diff
        run: |
          uv run --directory infra cdk diff \
            --exclusively \
            -c image_tag=${{ github.sha }} \
            ${{ steps.stacks.outputs.names }} \
            || true

      - name: CDK deploy
        run: |
          uv run --directory infra cdk deploy \
            --require-approval never \
            -c image_tag=${{ github.sha }} \
            ${{ steps.stacks.outputs.names }}

  # ============================================================
  # Deploy CDK infrastructure (serverless mode)
  # ============================================================
  deploy-cdk-serverless:
    name: Deploy CDK (Serverless)
    runs-on: ubuntu-latest
    needs: [setup, changes]
    if: needs.setup.outputs.need_serverless_cdk == 'true'
    permissions:
      id-token: write
      contents: read
    environment: ${{ inputs.environment || 'dev' }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Set up Python
        run: uv python install ${{ env.PYTHON_VERSION }}

      - name: Install CDK
        run: npm install -g aws-cdk

      - name: Determine stacks to deploy
        id: stacks
        run: |
          INFRA_FS="${{ needs.changes.outputs.infra_fs }}"
          LAMBDAS="${{ needs.changes.outputs.lambdas }}"
          WEB="${{ needs.changes.outputs.web }}"
          IS_DISPATCH="${{ github.event_name == 'workflow_dispatch' }}"

          if [ "$INFRA_FS" = "true" ] || [ "$IS_DISPATCH" = "true" ]; then
            echo "names=OmnichannelDataStack OmnichannelAuthStack OmnichannelApiStack OmnichannelWorkerStack OmnichannelSchedulerStack OmnichannelMonitoringStack OmnichannelSecurityStack OmnichannelFrontendStack" >> $GITHUB_OUTPUT
            exit 0
          fi

          STACKS=""

          if [ "$LAMBDAS" = "true" ]; then
            STACKS="OmnichannelDataStack OmnichannelAuthStack OmnichannelApiStack OmnichannelWorkerStack OmnichannelSchedulerStack OmnichannelMonitoringStack OmnichannelSecurityStack"
          fi

          if [ "$WEB" = "true" ]; then
            if [ -z "$STACKS" ]; then
              STACKS="OmnichannelFrontendStack"
            else
              STACKS="$STACKS OmnichannelFrontendStack"
            fi
          fi

          echo "names=$STACKS" >> $GITHUB_OUTPUT

      - name: CDK diff
        run: |
          uv run --directory infra-fs cdk diff \
            --exclusively \
            ${{ steps.stacks.outputs.names }} \
            || true

      - name: CDK deploy
        run: |
          uv run --directory infra-fs cdk deploy \
            --require-approval never \
            ${{ steps.stacks.outputs.names }}

  # ============================================================
  # Restore ECS desired counts (prevent CDK resetting to 0)
  # ============================================================
  restore-ecs-state:
    name: Restore ECS State
    runs-on: ubuntu-latest
    needs: [setup, save-ecs-state, deploy-cdk]
    if: |
      always()
      && needs.deploy-cdk.result == 'success'
      && needs.save-ecs-state.result == 'success'
      && needs.save-ecs-state.outputs.has_cluster == 'true'
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Restore desired counts
        env:
          API_COUNT: ${{ needs.save-ecs-state.outputs.api_count }}
          WORKER_COUNT: ${{ needs.save-ecs-state.outputs.worker_count }}
          SCHEDULER_COUNT: ${{ needs.save-ecs-state.outputs.scheduler_count }}
        run: |
          echo "Restoring ECS desired counts..."

          CLUSTER=$(aws ecs list-clusters \
            --query "clusterArns[?contains(@, 'ComputeStack')]" \
            --output text 2>/dev/null || true)

          if [ -z "$CLUSTER" ]; then
            echo "No ECS cluster found, skipping restore"
            exit 0
          fi

          # Discover actual service ARNs dynamically
          SVCS=$(aws ecs list-services --cluster "$CLUSTER" --query "serviceArns[]" --output text 2>/dev/null || true)

          for svc_arn in $SVCS; do
            SVC_NAME=$(echo "$svc_arn" | awk -F'/' '{print $NF}')
            TARGET_COUNT=0

            if echo "$SVC_NAME" | grep -qi "api"; then
              TARGET_COUNT="$API_COUNT"
            elif echo "$SVC_NAME" | grep -qi "worker"; then
              TARGET_COUNT="$WORKER_COUNT"
            elif echo "$SVC_NAME" | grep -qi "scheduler"; then
              TARGET_COUNT="$SCHEDULER_COUNT"
            fi

            if [ "$TARGET_COUNT" != "0" ] && [ -n "$TARGET_COUNT" ]; then
              echo "  Restoring $SVC_NAME to desired=$TARGET_COUNT"
              aws ecs update-service \
                --cluster "$CLUSTER" \
                --service "$svc_arn" \
                --desired-count "$TARGET_COUNT" \
                --no-cli-pager > /dev/null
            else
              echo "  $SVC_NAME was at 0, leaving as-is"
            fi
          done
          echo "Done"

  # ============================================================
  # Force new deployment on ECS services (only when images changed)
  # ============================================================
  deploy-services:
    name: Deploy Services
    runs-on: ubuntu-latest
    needs: [setup, changes, deploy-cdk, restore-ecs-state]
    if: |
      always()
      && needs.setup.outputs.infra_type == 'containers'
      && needs.changes.outputs.services == 'true'
      && needs.deploy-cdk.result == 'success'
    permissions:
      id-token: write
      contents: read
    environment: ${{ inputs.environment || 'dev' }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS services
        run: |
          CLUSTER=$(aws ecs list-clusters \
            --query "clusterArns[?contains(@, 'ComputeStack')]" \
            --output text 2>/dev/null || true)

          if [ -z "$CLUSTER" ]; then
            echo "No ECS cluster found, skipping"
            exit 0
          fi

          for svc_arn in $(aws ecs list-services --cluster "$CLUSTER" --query "serviceArns[]" --output text); do
            SVC_NAME=$(echo "$svc_arn" | awk -F'/' '{print $NF}')
            echo "Force new deployment: $SVC_NAME"
            aws ecs update-service \
              --cluster "$CLUSTER" \
              --service "$svc_arn" \
              --force-new-deployment \
              --no-cli-pager > /dev/null || true
          done

      - name: Wait for deployment
        run: |
          CLUSTER=$(aws ecs list-clusters \
            --query "clusterArns[?contains(@, 'ComputeStack')]" \
            --output text 2>/dev/null || true)

          if [ -z "$CLUSTER" ]; then exit 0; fi

          SVCS=$(aws ecs list-services --cluster "$CLUSTER" --query "serviceArns[]" --output text)
          aws ecs wait services-stable \
            --cluster "$CLUSTER" \
            --services $SVCS \
            --no-cli-pager || echo "Timeout waiting for services"

  # ============================================================
  # Run database migrations (only when service code changed)
  # ============================================================
  migrate:
    name: Run Migrations
    runs-on: ubuntu-latest
    needs: [setup, changes, deploy-services]
    if: |
      always()
      && needs.setup.outputs.infra_type == 'containers'
      && needs.changes.outputs.services == 'true'
      && needs.deploy-services.result == 'success'
    permissions:
      id-token: write
      contents: read
    environment: ${{ inputs.environment || 'dev' }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get network configuration from CloudFormation
        id: network
        run: |
          VPC_ID=$(aws cloudformation describe-stacks \
            --stack-name NetworkStack \
            --query "Stacks[0].Outputs[?OutputKey=='VpcId'].OutputValue" \
            --output text 2>/dev/null || echo "")

          if [ -z "$VPC_ID" ]; then
            echo "NetworkStack not found, skipping migrations"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" "Name=tag:aws-cdk:subnet-type,Values=Private" \
            --query "Subnets[*].SubnetId" \
            --output text | tr '\t' ',')

          SG_ID=$(aws cloudformation describe-stacks \
            --stack-name ComputeStack \
            --query "Stacks[0].Outputs[?OutputKey=='ServiceSecurityGroupId'].OutputValue" \
            --output text 2>/dev/null || echo "")

          if [ -z "$SG_ID" ]; then
            SG_ID=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" "Name=description,Values=*Fargate services*" \
              --query "SecurityGroups[0].GroupId" \
              --output text 2>/dev/null || echo "")
          fi

          echo "subnets=$SUBNETS" >> $GITHUB_OUTPUT
          echo "security_group=$SG_ID" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Run migrations
        if: steps.network.outputs.skip != 'true'
        run: |
          aws ecs run-task \
            --cluster secure-api-cluster \
            --task-definition api-migration \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ steps.network.outputs.subnets }}],securityGroups=[${{ steps.network.outputs.security_group }}],assignPublicIp=DISABLED}" \
            --no-cli-pager || echo "Migration task not configured yet"

  # ============================================================
  # Deploy EdgeStack (CloudFront + WAF) - manual trigger only
  # ============================================================
  deploy-edge:
    name: Deploy Edge (CloudFront + WAF)
    runs-on: ubuntu-latest
    needs: [setup, deploy-cdk]
    if: |
      needs.setup.outputs.infra_type == 'containers'
      && github.event_name == 'workflow_dispatch'
      && needs.deploy-cdk.result == 'success'
    permissions:
      id-token: write
      contents: read
    environment: ${{ inputs.environment || 'dev' }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Set up Python
        run: uv python install ${{ env.PYTHON_VERSION }}

      - name: Install CDK
        run: npm install -g aws-cdk

      - name: Deploy EdgeStack
        run: |
          uv run --directory infra cdk deploy EdgeStack \
            --require-approval never \
            -c image_tag=${{ github.sha }}

  # ============================================================
  # Notify on completion
  # ============================================================
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [setup, changes, build-and-push, deploy-cdk, deploy-cdk-serverless, restore-ecs-state, deploy-services, migrate]
    if: always()
    steps:
      - name: Determine deploy result
        id: result
        run: |
          BUILD="${{ needs.build-and-push.result }}"
          CDK="${{ needs.deploy-cdk.result }}"
          CDK_SL="${{ needs.deploy-cdk-serverless.result }}"
          SERVICES="${{ needs.deploy-services.result }}"
          MIGRATE="${{ needs.migrate.result }}"
          RESTORE="${{ needs.restore-ecs-state.result }}"

          # Check for actual failures (not skipped)
          FAILED="false"
          for r in "$BUILD" "$CDK" "$CDK_SL" "$SERVICES" "$MIGRATE" "$RESTORE"; do
            if [ "$r" = "failure" ]; then
              FAILED="true"
              break
            fi
          done

          # Check if anything actually ran
          ALL_SKIPPED="true"
          for r in "$BUILD" "$CDK" "$CDK_SL" "$SERVICES" "$MIGRATE"; do
            if [ "$r" != "skipped" ]; then
              ALL_SKIPPED="false"
              break
            fi
          done

          if [ "$FAILED" = "true" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=❌" >> $GITHUB_OUTPUT
            echo "text=Deploy Failed" >> $GITHUB_OUTPUT
          elif [ "$ALL_SKIPPED" = "true" ]; then
            echo "status=skipped" >> $GITHUB_OUTPUT
            echo "emoji=⏭️" >> $GITHUB_OUTPUT
            echo "text=Deploy Skipped (no relevant changes)" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=✅" >> $GITHUB_OUTPUT
            echo "text=Deploy Succeeded" >> $GITHUB_OUTPUT
          fi

          # Build summary of what ran
          SUMMARY=""
          if [ "$BUILD" = "success" ]; then SUMMARY="${SUMMARY}Containers ✅ "; fi
          if [ "$CDK" = "success" ]; then SUMMARY="${SUMMARY}CDK ✅ "; fi
          if [ "$CDK_SL" = "success" ]; then SUMMARY="${SUMMARY}CDK-Serverless ✅ "; fi
          if [ "$RESTORE" = "success" ]; then SUMMARY="${SUMMARY}ECS-Restored ✅ "; fi
          if [ "$SERVICES" = "success" ]; then SUMMARY="${SUMMARY}ECS-Deploy ✅ "; fi
          if [ "$MIGRATE" = "success" ]; then SUMMARY="${SUMMARY}Migrations ✅ "; fi
          echo "summary=${SUMMARY:-No jobs ran}" >> $GITHUB_OUTPUT

      - name: Slack notification
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "${{ steps.result.outputs.emoji }} ${{ steps.result.outputs.text }}",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {"type": "mrkdwn", "text": "*Repository:*\n${{ github.repository }}"},
                    {"type": "mrkdwn", "text": "*Branch:*\n${{ github.ref_name }}"}
                  ]
                },
                {
                  "type": "section",
                  "fields": [
                    {"type": "mrkdwn", "text": "*Infra:*\n${{ needs.setup.outputs.infra_type }}"},
                    {"type": "mrkdwn", "text": "*Jobs:*\n${{ steps.result.outputs.summary }}"}
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {"type": "plain_text", "text": "View Run"},
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
